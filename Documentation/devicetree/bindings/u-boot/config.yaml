# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
%YAML 1.2
---
$id: http://devicetree.org/schemas/u-boot/config.yaml#
$schema: http://devicetree.org/meta-schemas/core.yaml#

title: U-Boot configuration node

maintainers:
  - Simon Glass <sjg@chromium.org>

description: |
  The config node does not represent a real device, but serves as a place
  for passing data between firmware elements, like memory maps. Data in the
  config node does not represent the hardware. It is ignored by operating
  systems.

  Purpose of config node
  ----------------------

  A common problem with firmware is that many builds are needed to deal with the
  slight variations between different, related models. For example, one model
  may have a TPM and another may not. Devicetree provides an excellent solution
  to this problem, in that the devicetree to actually use on a platform can be
  injected in the factory based on which model is being manufactured at the time.

  A related problem causing build proliferation is dealing with the differences
  between development firmware, developer-friendly firmware (e.g. with all
  security features present but with the ability to access the command line),
  test firmware (which runs tests used in the factory), final production
  firmware (before signing), signed firmware (where the signatures have been
  inserted) and the like. Ideally all or most of these should use the same
  U-Boot build, with just some options to determine the features available. For
  example, being able to control whether the UART console or JTAG are available,
  on any image, is a great debugging aid.

  When the firmware consists of multiple parts (various U-Boot phases, TF-A,
  OP-TEE), it is helpful that all operate the same way at runtime, regardless of
  how they were built. This can be achieved by passing the runtime configuration
  (e.g. 'enable UART console', 'here are your public keys') along the chain
  through each firmware stage. It is frustrating to have to replicate a bug on
  production firmware which does happen on developer firmware, because they are
  completely different builds.

  The config node provides useful functionality for this. It allows the different
  controls to be 'factored out' of the U-Boot binary, so they can be controlled
  separately from the initial source-code build. The node can be easily updated
  by a build or factory tool and can control various features in U-Boot. It is
  similar in concept to a Kconfig option, except that it can be changed after
  U-Boot is built.

  The config node is similar in concept to /chosen (see chosen.yaml) except that
  it is for passing information *into* and *between) firmware components,
  instead of from firmware to the Operating System. Also, while operating
  systems typically have a (sometimes extremely long) command line, U-Boot does
  not support this, except with sandbox. The devicetree provides a more
  structured approach in any case.

properties:

  compatible:
    enum:
      - u-boot,config

  bootcmd:
    $ref: /schemas/types.yaml#/definitions/string
    description: |
      Allows overwriting of the boot command used by U-Boot on startup. If
      present, U-Boot uses this command instead. Note that this feature can
      work even if loading the environment is disabled, e.g. for security
      reasons. See also bootsecure.

  bootdelay-sec:
    description: |
      Allows selecting of the U-Boot bootdelay, to control whether U-Boot
      waits on boot or for how long. This allows this option to be configured
      by the build system or by a previous-stage binary. For example, if the
      images is being packed for testing or a user holds down a button, it may
      allow a delay, but disable it for production.

      If this property is not present, a default value is used instead.

      Note that this uses the 'sec' property unit, even though it allows a
      negative value.

      Values:

      -1: no bootdelay and the user cannot interrupt boot
      0: no bootdelay but use user can still interrupt boot by holding down a
        key, if enabled
      >= 1: delay for this many seconds


  bootsecure:
    $ref: /schemas/types.yaml#/definitions/uint32
    default: 0
    maximum: 2
    description: |
      Controls the execution of the boot command in U-Boot, e.g. selecting
      between using a special function to run commands, or the normal CLI. This
      can be used in production images, to restrict the amount of parsing done
      or the options available, to cut back on the available surface for
      security attacks.

      Values:

      0: normal boot using CLI (default if not present)
      1: use secure boot mechanism instead to parse and run commands
        other values are reserved for future use
      2: use simplified command line (e.g. avoid hush)
      3... reserved

  silent-console:
    $ref: /schemas/types.yaml#/definitions/uint32
    default: 0
    maximum: 2
    description: |
      This allows the console to be silenced by default on boot. This can allow
      easy disabling of console output on a production build, for example. When
      suppressed, the console is still active. This feature only suppresses the
      console output itself, on all output devices.

      Values:

      0: console output appears as normal (default)
      1: console output is suppressed but console recording still operates (if
        enabled)
      2: console output is suppressed and not recorded

required:
  - compatible

additionalProperties: false

examples:
  - |
    u-boot,config {
      compatible = "u-boot,config";
      bootcmd = "vboot go auto";
      bootdelay-sec = <(-1)>;
      bootsecure = <1>;
      silent-console = <1>;
    };
